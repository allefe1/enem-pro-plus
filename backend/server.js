const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const axios = require('axios');

dotenv.config();

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(express.json());

// Base URL da API do ENEM
const ENEM_API_BASE = 'https://api.enem.dev/v1';

// üîß CONFIGURA√á√ÉO DE LOGS DETALHADOS
const logRequest = (config) => {
  console.log('\nüöÄ INICIANDO REQUISI√á√ÉO:');
  console.log(`   M√©todo: ${config.method?.toUpperCase()}`);
  console.log(`   URL: ${config.url}`);
  if (config.params) {
    console.log(`   Par√¢metros: ${JSON.stringify(config.params, null, 2)}`);
  }
  console.log(`   Timeout: ${config.timeout || 'Padr√£o'}`);
  console.log('‚îÄ'.repeat(50));
};

const logResponse = (response) => {
  console.log('\n‚úÖ RESPOSTA RECEBIDA:');
  console.log(`   Status: ${response.status} ${response.statusText}`);
  if (response.data.questions) {
    console.log(`   Total de quest√µes: ${response.data.questions.length}`);
  }
  console.log('‚îÄ'.repeat(50));
};

const logError = (error) => {
  console.log('\n‚ùå ERRO NA REQUISI√á√ÉO:');
  
  if (error.response) {
    console.log(`   Status: ${error.response.status} ${error.response.statusText}`);
    console.log(`   Dados do erro: ${JSON.stringify(error.response.data, null, 2)}`);
  } else if (error.request) {
    console.log('   Tipo: Timeout ou erro de rede');
  } else {
    console.log(`   Mensagem: ${error.message}`);
  }
  
  console.log(`   C√≥digo de erro: ${error.code}`);
  console.log('‚îÄ'.repeat(50));
};

// üåê INTERCEPTOR GLOBAL DO AXIOS
axios.interceptors.request.use(
  (config) => {
    logRequest(config);
    return config;
  },
  (error) => {
    console.log('‚ùå Erro no interceptor de requisi√ß√£o:', error);
    return Promise.reject(error);
  }
);

axios.interceptors.response.use(
  (response) => {
    logResponse(response);
    return response;
  },
  (error) => {
    logError(error);
    return Promise.reject(error);
  }
);

// üîç Fun√ß√£o auxiliar para mapear disciplinas
function mapearDisciplina(discipline) {
  const mapeamento = {
    'matematica': 'Matem√°tica',
    'linguagens': 'Linguagens',
    'ciencias-humanas': 'Ci√™ncias Humanas',
    'ciencias-natureza': 'Ci√™ncias da Natureza'
  };
  return mapeamento[discipline] || discipline || 'Disciplina n√£o especificada';
}

// üéØ NOVA FUN√á√ÉO: Verificar ader√™ncia ao tema (como no ENEM real)
async function verificarAderenciaAoTema(redacao, tema) {
  try {
    const prompt = `Voc√™ √© um corretor especializado do ENEM. Analise se esta reda√ß√£o EST√Å NO TEMA proposto.

TEMA PROPOSTO: "${tema}"

REDA√á√ÉO: "${redacao}"

CRIT√âRIOS R√çGIDOS (como no ENEM real):
- FUGA TOTAL: reda√ß√£o n√£o menciona nada relacionado ao tema espec√≠fico = NOTA ZERO autom√°tica
- TANGENCIAMENTO: aborda assunto geral mas n√£o o recorte espec√≠fico do tema = m√°ximo 40 pontos por compet√™ncia
- ADERENTE: aborda especificamente o tema proposto

Analise se h√° palavras-chave do tema na reda√ß√£o e se o foco est√° correto.

Responda APENAS no formato JSON:
{
  "aderente_ao_tema": true/false,
  "tipo_desvio": "nenhum" | "tangenciamento" | "fuga_total",
  "explicacao": "explica√ß√£o detalhada do motivo",
  "palavras_chave_tema": ["palavra1", "palavra2"],
  "palavras_chave_encontradas": ["palavra1"],
  "pode_prosseguir": true/false,
  "nivel_gravidade": 0-10
}`;

    const response = await axios.post('https://openrouter.ai/api/v1/chat/completions', {
      model: 'qwen/qwen3-coder:free',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.3, // Baixa temperatura para an√°lise mais precisa
      max_tokens: 800
    }, {
      headers: {
        'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': 'http://localhost:3000',
        'X-Title': 'ENEM Pro+'
      }
    });

    const avaliacaoTexto = response.data.choices[0].message.content;
    
    // Extrair JSON da resposta
    const jsonMatch = avaliacaoTexto.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch);
    } else {
      throw new Error('JSON n√£o encontrado na resposta da verifica√ß√£o de tema');
    }

  } catch (error) {
    console.error('Erro na verifica√ß√£o do tema:', error);
    // Em caso de erro, assumir que est√° no tema para n√£o prejudicar o usu√°rio
    return {
      aderente_ao_tema: true,
      tipo_desvio: "nenhum",
      explicacao: "Erro na verifica√ß√£o autom√°tica do tema",
      palavras_chave_tema: [],
      palavras_chave_encontradas: [],
      pode_prosseguir: true,
      nivel_gravidade: 0
    };
  }
}

// üìä Rota para listar todas as provas dispon√≠veis
app.get('/api/provas', async (req, res) => {
  console.log('\nüéØ CHAMADA: /api/provas');
  
  try {
    const response = await axios.get(`${ENEM_API_BASE}/exams`, {
      timeout: 10000,
      headers: {
        'User-Agent': 'ENEM-Pro-Plus/1.0',
        'Accept': 'application/json'
      }
    });
    
    console.log(`‚úÖ Provas encontradas: ${response.data.length}`);
    res.json(response.data);
    
  } catch (error) {
    console.log('‚ùå Erro ao buscar provas');
    res.status(500).json({ 
      error: 'Erro ao buscar provas',
      details: error.message,
      code: error.code || 'UNKNOWN'
    });
  }
});

// üìù Rota para detalhes de uma prova espec√≠fica
app.get('/api/provas/:ano', async (req, res) => {
  console.log('\nüéØ CHAMADA: /api/provas/:ano');
  
  try {
    const { ano } = req.params;
    const response = await axios.get(`${ENEM_API_BASE}/exams/${ano}`, {
      timeout: 10000,
      headers: {
        'User-Agent': 'ENEM-Pro-Plus/1.0',
        'Accept': 'application/json'
      }
    });
    
    res.json(response.data);
    
  } catch (error) {
    console.log('‚ùå Erro ao buscar prova espec√≠fica');
    res.status(500).json({ 
      error: 'Prova n√£o encontrada',
      details: error.message 
    });
  }
});

// üìã Rota principal para quest√µes
app.get('/api/questoes', async (req, res) => {
  const startTime = Date.now();
  console.log('\nüéØ CHAMADA: /api/questoes');
  
  try {
    const { 
      ano = 2023, 
      limit = 10, 
      offset = 0,
      disciplina = '',
      language = '' // Ser√° usado apenas se disciplina for 'linguagens'
    } = req.query;
    
    console.log(`üìù Par√¢metros recebidos:`, { ano, limit, offset, disciplina, language });
    
    // Valida√ß√£o b√°sica
    if (!ano || isNaN(parseInt(ano))) {
      throw new Error(`Ano inv√°lido: ${ano}`);
    }
    
    const apiUrl = `${ENEM_API_BASE}/exams/${ano}/questions`;
    console.log(`üîó URL da API: ${apiUrl}`);
    
    // Preparar par√¢metros base
    const params = {
      limit: Math.min(parseInt(limit), 50), // M√°ximo 50 permitido pela API
      offset: parseInt(offset)
    };
    
    // üåê ADICIONAR LANGUAGE APENAS PARA LINGUAGENS
    if (disciplina === 'linguagens' && language) {
      const idiomasValidos = ['ingl√™s', 'espanhol'];
      if (idiomasValidos.includes(language)) {
        params.language = language;
        console.log(`üåê Idioma selecionado para Linguagens: ${language}`);
      } else {
        params.language = 'ingl√™s'; // padr√£o para linguagens
        console.log(`üåê Idioma inv√°lido, usando ingl√™s como padr√£o para Linguagens`);
      }
    } else if (disciplina === 'linguagens') {
      params.language = 'ingl√™s'; // padr√£o se n√£o especificado
      console.log(`üåê Usando ingl√™s como padr√£o para Linguagens`);
    } else {
      console.log(`üìö Disciplina ${disciplina || 'todas'}: sem par√¢metro de idioma (portugu√™s)`);
    }
    
    const response = await axios.get(apiUrl, {
      params: params,
      timeout: 15000,
      headers: {
        'User-Agent': 'ENEM-Pro-Plus/1.0',
        'Accept': 'application/json'
      }
    });
    
    console.log(`‚è±Ô∏è  Tempo de resposta: ${Date.now() - startTime}ms`);
    
    // Verificar estrutura da resposta
    if (!response.data || !response.data.questions) {
      throw new Error('Resposta da API inv√°lida');
    }
    
    if (response.data.questions.length === 0) {
      console.log('‚ö†Ô∏è  Nenhuma quest√£o encontrada');
      return res.json({
        questoes: [],
        metadata: {
          total: 0,
          message: 'Nenhuma quest√£o encontrada',
          parametros: { ano, limit, offset, disciplina }
        }
      });
    }
    
    // Filtrar por disciplina se especificada
    let questoesFiltradas = response.data.questions;
    if (disciplina) {
      questoesFiltradas = response.data.questions.filter(q => q.discipline === disciplina);
      console.log(`üîç Filtradas ${questoesFiltradas.length} quest√µes de ${disciplina} de um total de ${response.data.questions.length}`);
    }
    
    // Mapear quest√µes para formato compat√≠vel
    const questoesFormatadas = questoesFiltradas.map((questao, index) => {
      return {
        id: questao.index || questao.id || index + 1,
        index: questao.index,
        area: mapearDisciplina(questao.discipline),
        discipline: questao.discipline,
        tema: questao.title || 'Quest√£o ENEM',
        title: questao.title,
        ano: questao.year || parseInt(ano),
        year: questao.year,
        enunciado: questao.context || questao.title || 'Enunciado n√£o dispon√≠vel',
        context: questao.context,
        alternativas: questao.alternatives?.map(alt => 
          `${alt.letter}) ${alt.text || alt.file || 'Alternativa com arquivo'}`
        ) || [],
        alternatives: questao.alternatives,
        gabarito: questao.correctAlternative,
        correctAlternative: questao.correctAlternative,
        comentario: `Quest√£o ${questao.index || index + 1} do ENEM ${questao.year || ano} - ${questao.discipline}`,
        files: questao.files || [],
        alternativesIntroduction: questao.alternativesIntroduction,
        // Incluir idioma apenas se for linguagens
        ...(questao.discipline === 'linguagens' && { 
          idioma: params.language || 'ingl√™s',
          tipoLinguagem: (params.language || 'ingl√™s') === 'ingl√™s' ? 'L√≠ngua Inglesa' : 'L√≠ngua Espanhola'
        })
      };
    });
    
    console.log(`‚úÖ ${questoesFormatadas.length} quest√µes formatadas com sucesso`);
    
    const resposta = {
      questoes: questoesFormatadas,
      metadata: {
        total: response.data.metadata?.total || questoesFormatadas.length,
        ano: ano,
        limit: parseInt(limit),
        offset: parseInt(offset),
        disciplina: disciplina || 'todas',
        // Incluir language apenas se for linguagens
        ...(disciplina === 'linguagens' && { language: params.language || 'ingl√™s' }),
        tempoResposta: `${Date.now() - startTime}ms`,
        ...response.data.metadata
      }
    };
    
    res.json(resposta);
    
  } catch (error) {
    console.log(`‚ùå Erro completo ap√≥s ${Date.now() - startTime}ms:`);
    console.log(`   Mensagem: ${error.message}`);
    
    res.status(500).json({ 
      error: 'Erro ao buscar quest√µes',
      details: error.message,
      code: error.code || 'UNKNOWN',
      tempo: `${Date.now() - startTime}ms`,
      parametros: req.query
    });
  }
});

// üîç Rota para quest√µes por disciplina espec√≠fica - CORRIGIDA
app.get('/api/questoes/disciplina/:disciplina', async (req, res) => {
  const startTime = Date.now();
  console.log('\nüéØ CHAMADA: /api/questoes/disciplina/:disciplina');
  
  try {
    const { disciplina } = req.params;
    const { 
      ano = 2023, 
      limit = 20,
      language = '' // Ser√° usado apenas se disciplina for 'linguagens'
    } = req.query;
    
    console.log(`üìù Buscando quest√µes:`, { disciplina, ano, limit, language });
    
    // Preparar par√¢metros base
    const params = {
      limit: 50, // M√°ximo permitido pela API
      offset: 0
    };
    
    // üåê ADICIONAR LANGUAGE APENAS PARA LINGUAGENS
    if (disciplina === 'linguagens') {
      const idiomasValidos = ['ingl√™s', 'espanhol'];
      if (language && idiomasValidos.includes(language)) {
        params.language = language;
        console.log(`üåê Idioma para Linguagens: ${language}`);
      } else {
        params.language = 'ingl√™s';
        console.log(`üåê Usando ingl√™s como padr√£o para Linguagens`);
      }
    } else {
      console.log(`üìö Disciplina ${disciplina}: quest√µes em portugu√™s (sem par√¢metro language)`);
    }
    
    console.log(`üî¢ Par√¢metros finais da API:`, params);
    
    const response = await axios.get(
      `${ENEM_API_BASE}/exams/${ano}/questions`,
      { 
        params: params,
        timeout: 15000,
        headers: {
          'User-Agent': 'ENEM-Pro-Plus/1.0',
          'Accept': 'application/json'
        }
      }
    );
    
    if (!response.data.questions) {
      throw new Error('Nenhuma quest√£o encontrada na resposta');
    }
    
    console.log(`üìä Total de quest√µes recebidas da API: ${response.data.questions.length}`);
    
    // Filtrar por disciplina
    const questoesFiltradas = response.data.questions
      .filter(q => q.discipline === disciplina)
      .slice(0, parseInt(limit)); // Aplicar limit do usu√°rio ap√≥s filtrar
    
    console.log(`üîç Quest√µes filtradas: ${questoesFiltradas.length} de ${response.data.questions.length} (disciplina: ${disciplina})`);
    
    // Log das disciplinas encontradas para debug
    const disciplinasEncontradas = [...new Set(response.data.questions.map(q => q.discipline))];
    console.log(`üìö Disciplinas dispon√≠veis na resposta:`, disciplinasEncontradas);
    
    // Se n√£o encontrou quest√µes da disciplina
    if (questoesFiltradas.length === 0) {
      console.log(`‚ö†Ô∏è Nenhuma quest√£o de '${disciplina}' encontrada`);
      console.log(`üí° Verifique se o nome da disciplina est√° correto: ${disciplinasEncontradas.join(', ')}`);
      
      return res.json({
        questoes: [],
        total: 0,
        disciplina: disciplina,
        ano: ano,
        disciplinasDisponiveis: disciplinasEncontradas,
        message: `Nenhuma quest√£o de '${disciplina}' encontrada. Disciplinas dispon√≠veis: ${disciplinasEncontradas.join(', ')}`,
        tempoResposta: `${Date.now() - startTime}ms`
      });
    }
    
    const questoesFormatadas = questoesFiltradas.map((questao, index) => ({
      id: questao.index || questao.id || index + 1,
      index: questao.index,
      area: mapearDisciplina(questao.discipline),
      discipline: questao.discipline,
      tema: questao.title || 'Quest√£o ENEM',
      title: questao.title,
      ano: questao.year || parseInt(ano),
      year: questao.year,
      enunciado: questao.context || questao.title || 'Enunciado n√£o dispon√≠vel',
      context: questao.context,
      alternativas: questao.alternatives?.map(alt => 
        `${alt.letter}) ${alt.text || alt.file || 'Alternativa com arquivo'}`
      ) || [],
      alternatives: questao.alternatives,
      gabarito: questao.correctAlternative,
      correctAlternative: questao.correctAlternative,
      comentario: `Quest√£o ${questao.index || index + 1} do ENEM ${questao.year || ano} - ${questao.discipline}`,
      files: questao.files || [],
      alternativesIntroduction: questao.alternativesIntroduction,
      // Incluir idioma apenas se for linguagens
      ...(disciplina === 'linguagens' && { 
        idioma: params.language,
        tipoLinguagem: params.language === 'ingl√™s' ? 'L√≠ngua Inglesa' : 'L√≠ngua Espanhola'
      })
    }));
    
    console.log(`‚úÖ ${questoesFormatadas.length} quest√µes formatadas com sucesso`);
    
    res.json({
      questoes: questoesFormatadas,
      total: questoesFormatadas.length,
      disciplina: disciplina,
      ano: ano,
      // Incluir language apenas se for linguagens
      ...(disciplina === 'linguagens' && { language: params.language }),
      tempoResposta: `${Date.now() - startTime}ms`
    });
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar quest√µes por disciplina:', error);
    res.status(500).json({ 
      error: 'Erro ao buscar quest√µes por disciplina',
      details: error.message,
      disciplina: req.params.disciplina
    });
  }
});

// üìÑ Rota para quest√£o espec√≠fica
app.get('/api/questoes/:ano/:index', async (req, res) => {
  console.log('\nüéØ CHAMADA: /api/questoes/:ano/:index');
  
  try {
    const { ano, index } = req.params;
    const { language = '' } = req.query;
    
    console.log(`üìù Buscando quest√£o espec√≠fica:`, { ano, index, language });
    
    // Primeiro, tentar buscar sem language
    let params = { limit: 50, offset: 0 };
    
    let response = await axios.get(
      `${ENEM_API_BASE}/exams/${ano}/questions`,
      { 
        params: params,
        timeout: 10000,
        headers: {
          'User-Agent': 'ENEM-Pro-Plus/1.0',
          'Accept': 'application/json'
        }
      }
    );
    
    let questao = response.data.questions?.find(q => q.index === parseInt(index));
    
    // Se n√£o encontrou e tem language, tentar com language (para linguagens)
    if (!questao && language && ['ingl√™s', 'espanhol'].includes(language)) {
      console.log(`üîç Quest√£o n√£o encontrada sem language, tentando com language: ${language}`);
      params.language = language;
      
      response = await axios.get(
        `${ENEM_API_BASE}/exams/${ano}/questions`,
        { 
          params: params,
          timeout: 10000,
          headers: {
            'User-Agent': 'ENEM-Pro-Plus/1.0',
            'Accept': 'application/json'
          }
        }
      );
      
      questao = response.data.questions?.find(q => q.index === parseInt(index));
    }
    
    if (!questao) {
      return res.status(404).json({ 
        error: 'Quest√£o n√£o encontrada',
        ano: ano,
        index: index,
        language: language || 'N/A'
      });
    }
    
    // Formata√ß√£o da quest√£o espec√≠fica
    const questaoFormatada = {
      id: questao.index,
      index: questao.index,
      area: mapearDisciplina(questao.discipline),
      discipline: questao.discipline,
      tema: questao.title || 'Quest√£o ENEM',
      title: questao.title,
      ano: questao.year,
      year: questao.year,
      enunciado: questao.context || questao.title,
      context: questao.context,
      alternativas: questao.alternatives?.map(alt => 
        `${alt.letter}) ${alt.text || alt.file || 'Alternativa com arquivo'}`
      ) || [],
      alternatives: questao.alternatives,
      gabarito: questao.correctAlternative,
      correctAlternative: questao.correctAlternative,
      comentario: `Quest√£o ${questao.index} do ENEM ${questao.year} - ${questao.discipline}`,
      files: questao.files || [],
      alternativesIntroduction: questao.alternativesIntroduction,
      // Incluir idioma apenas se for linguagens
      ...(questao.discipline === 'linguagens' && { 
        idioma: params.language || 'ingl√™s',
        tipoLinguagem: (params.language || 'ingl√™s') === 'ingl√™s' ? 'L√≠ngua Inglesa' : 'L√≠ngua Espanhola'
      })
    };
    
    console.log(`‚úÖ Quest√£o ${index} encontrada e formatada`);
    res.json(questaoFormatada);
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar quest√£o espec√≠fica:', error);
    res.status(500).json({ 
      error: 'Quest√£o n√£o encontrada',
      details: error.message 
    });
  }
});

// üß™ Rota de teste da API externa
app.get('/api/teste-api-externa', async (req, res) => {
  console.log('\nüß™ TESTE DIRETO DA API EXTERNA');
  
  try {
    const { language = '', disciplina = '' } = req.query;
    
    const params = { limit: 1 };
    
    // Testar language apenas se for linguagens
    if (disciplina === 'linguagens' && ['ingl√™s', 'espanhol'].includes(language)) {
      params.language = language;
    }
    
    const response = await axios.get('https://api.enem.dev/v1/exams/2023/questions', {
      params: params,
      timeout: 10000,
      headers: {
        'User-Agent': 'ENEM-Pro-Plus/1.0',
        'Accept': 'application/json'
      }
    });
    
    res.json({
      status: 'success',
      message: 'API externa funcionando',
      disciplina: disciplina || 'todas',
      language: disciplina === 'linguagens' ? (language || 'ingl√™s') : 'N/A (portugu√™s)',
      dados: response.data,
      statusCode: response.status
    });
    
  } catch (error) {
    res.json({
      status: 'error',
      message: 'Erro na API externa',
      error: error.message,
      code: error.code
    });
  }
});

// üé® Rota para corre√ß√£o de reda√ß√£o com IA - ATUALIZADA COM VERIFICA√á√ÉO DE TEMA
app.post('/api/corrigir-redacao', async (req, res) => {
  try {
    const { redacao, tema } = req.body;
    
    console.log('\nüéØ CORRE√á√ÉO DE REDA√á√ÉO INICIADA');
    console.log(`üìù Tema: ${tema}`);
    console.log(`üìÑ Reda√ß√£o: ${redacao.length} caracteres`);
    
    if (!redacao || !tema) {
      return res.status(400).json({ error: 'Reda√ß√£o e tema s√£o obrigat√≥rios' });
    }
    
    // üö® ETAPA 1: Verificar ader√™ncia ao tema (como no ENEM real)
    console.log('üîç Verificando ader√™ncia ao tema...');
    const verificacaoTema = await verificarAderenciaAoTema(redacao, tema);
    
    console.log('üìä Resultado da verifica√ß√£o:', verificacaoTema);
    
    // Se fugiu do tema, retornar nota conforme ENEM
    if (!verificacaoTema.aderente_ao_tema) {
      console.log(`‚ö†Ô∏è DETECTADA ${verificacaoTema.tipo_desvio.toUpperCase()}: ${verificacaoTema.explicacao}`);
      
      const notasPorDesvio = {
        fuga_total: { c1: 0, c2: 0, c3: 0, c4: 0, c5: 0, total: 0 },
        tangenciamento: { c1: 40, c2: 40, c3: 40, c4: 40, c5: 40, total: 200 }
      };
      
      const notas = notasPorDesvio[verificacaoTema.tipo_desvio] || notasPorDesvio.fuga_total;
      
      return res.json({
        competencias: [
          {
            numero: 1,
            nome: "Dom√≠nio da modalidade escrita formal",
            nota: notas.c1,
            explicacao: verificacaoTema.tipo_desvio === 'fuga_total' 
              ? "Nota zero devido √† fuga total do tema." 
              : "Nota reduzida devido ao tangenciamento do tema.",
            sugestoes: "Leia atentamente o tema e certifique-se de abord√°-lo especificamente."
          },
          {
            numero: 2,
            nome: "Compreens√£o da proposta",
            nota: notas.c2,
            explicacao: `${verificacaoTema.tipo_desvio === 'fuga_total' ? 'FUGA TOTAL' : 'TANGENCIAMENTO'} DO TEMA: ${verificacaoTema.explicacao}`,
            sugestoes: "Identifique as palavras-chave do tema e desenvolva argumentos espec√≠ficos sobre elas."
          },
          {
            numero: 3,
            nome: "Organiza√ß√£o de informa√ß√µes",
            nota: notas.c3,
            explicacao: verificacaoTema.tipo_desvio === 'fuga_total' 
              ? "Prejudicado pela fuga total do tema." 
              : "Prejudicado pelo tangenciamento do tema.",
            sugestoes: "Use dados e informa√ß√µes diretamente relacionados ao tema espec√≠fico."
          },
          {
            numero: 4,
            nome: "Mecanismos lingu√≠sticos",
            nota: notas.c4,
            explicacao: verificacaoTema.tipo_desvio === 'fuga_total' 
              ? "Prejudicado pela fuga total do tema." 
              : "Prejudicado pelo tangenciamento do tema.",
            sugestoes: "Construa argumentos coesos focados no tema proposto."
          },
          {
            numero: 5,
            nome: "Proposta de interven√ß√£o",
            nota: notas.c5,
            explicacao: verificacaoTema.tipo_desvio === 'fuga_total' 
              ? "Imposs√≠vel avaliar devido √† fuga do tema." 
              : "Proposta n√£o direcionada especificamente ao tema.",
            sugestoes: "Elabore uma proposta de interven√ß√£o espec√≠fica para o problema apresentado no tema."
          }
        ],
        nota_total: notas.total,
        comentario_geral: `‚ö†Ô∏è ATEN√á√ÉO: ${verificacaoTema.tipo_desvio === 'fuga_total' ? 'FUGA TOTAL' : 'TANGENCIAMENTO'} DO TEMA DETECTADO!
        
${verificacaoTema.explicacao}

${verificacaoTema.palavras_chave_tema?.length > 0 ? `Palavras-chave do tema que deveriam ser abordadas: ${verificacaoTema.palavras_chave_tema.join(', ')}` : ''}

${verificacaoTema.palavras_chave_encontradas?.length > 0 ? `Palavras encontradas na reda√ß√£o: ${verificacaoTema.palavras_chave_encontradas.join(', ')}` : 'Nenhuma palavra-chave do tema foi encontrada na reda√ß√£o.'}

No ENEM real, ${verificacaoTema.tipo_desvio === 'fuga_total' ? 'isso resultaria em NOTA ZERO' : 'a nota m√°xima seria 200 pontos'}!`,
        fuga_tema: true,
        tipo_desvio: verificacaoTema.tipo_desvio,
        palavras_chave_tema: verificacaoTema.palavras_chave_tema || [],
        palavras_chave_encontradas: verificacaoTema.palavras_chave_encontradas || []
      });
    }
    
    // ‚úÖ ETAPA 2: Se est√° no tema, fazer corre√ß√£o completa normal
    console.log('‚úÖ Reda√ß√£o aderente ao tema. Prosseguindo com corre√ß√£o completa...');
    
    const prompt = `Voc√™ √© um corretor especialista em reda√ß√µes do ENEM. Avalie a seguinte reda√ß√£o sobre o tema "${tema}" de acordo com as 5 compet√™ncias do ENEM, atribuindo uma nota de 0 a 200 para cada compet√™ncia e explicando o motivo da pontua√ß√£o. Tamb√©m forne√ßa sugest√µes de melhoria para cada compet√™ncia.

Compet√™ncias do ENEM:
1. Demonstrar dom√≠nio da modalidade escrita formal da l√≠ngua portuguesa
2. Compreender a proposta de reda√ß√£o e aplicar conceitos das v√°rias √°reas de conhecimento
3. Selecionar, relacionar, organizar e interpretar informa√ß√µes, fatos, opini√µes e argumentos
4. Demonstrar conhecimento dos mecanismos lingu√≠sticos necess√°rios para a constru√ß√£o da argumenta√ß√£o
5. Elaborar proposta de interven√ß√£o para o problema abordado

Reda√ß√£o:
"${redacao}"

Forne√ßa a resposta no seguinte formato JSON:
{
  "competencias": [
    {
      "numero": 1,
      "nome": "Dom√≠nio da modalidade escrita formal",
      "nota": 160,
      "explicacao": "Explica√ß√£o detalhada da nota",
      "sugestoes": "Sugest√µes espec√≠ficas de melhoria"
    }
  ],
  "nota_total": 800,
  "comentario_geral": "Coment√°rio geral sobre a reda√ß√£o"
}`;

    const response = await axios.post('https://openrouter.ai/api/v1/chat/completions', {
      model: 'qwen/qwen3-coder:free',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.7,
      max_tokens: 2000
    }, {
      headers: {
        'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': 'http://localhost:3000',
        'X-Title': 'ENEM Pro+'
      }
    });
    
    const avaliacaoTexto = response.data.choices[0].message.content;
    
    let avaliacao;
    try {
      const jsonMatch = avaliacaoTexto.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        avaliacao = JSON.parse(jsonMatch);
        avaliacao.fuga_tema = false; // Marcar que N√ÉO fugiu do tema
      } else {
        throw new Error('JSON n√£o encontrado na resposta');
      }
    } catch (parseError) {
      console.log('‚ö†Ô∏è Erro ao parsear JSON, usando avalia√ß√£o padr√£o');
      avaliacao = {
        competencias: [
          {
            numero: 1,
            nome: "Dom√≠nio da modalidade escrita formal",
            nota: 140,
            explicacao: "An√°lise baseada na resposta da IA",
            sugestoes: "Revisar ortografia e gram√°tica"
          },
          {
            numero: 2,
            nome: "Compreens√£o da proposta",
            nota: 140,
            explicacao: "An√°lise baseada na resposta da IA",
            sugestoes: "Desenvolver melhor o tema proposto"
          },
          {
            numero: 3,
            nome: "Organiza√ß√£o de informa√ß√µes",
            nota: 140,
            explicacao: "An√°lise baseada na resposta da IA",
            sugestoes: "Melhorar a estrutura argumentativa"
          },
          {
            numero: 4,
            nome: "Mecanismos lingu√≠sticos",
            nota: 140,
            explicacao: "An√°lise baseada na resposta da IA",
            sugestoes: "Usar mais conectivos e elementos coesivos"
          },
          {
            numero: 5,
            nome: "Proposta de interven√ß√£o",
            nota: 140,
            explicacao: "An√°lise baseada na resposta da IA",
            sugestoes: "Elaborar proposta mais detalhada e vi√°vel"
          }
        ],
        nota_total: 700,
        comentario_geral: avaliacaoTexto,
        fuga_tema: false
      };
    }
    
    console.log(`‚úÖ Corre√ß√£o conclu√≠da. Nota total: ${avaliacao.nota_total}/1000`);
    res.json(avaliacao);
    
  } catch (error) {
    console.error('‚ùå Erro ao corrigir reda√ß√£o:', error);
    res.status(500).json({ 
      error: 'Erro interno do servidor ao processar a reda√ß√£o',
      details: error.message 
    });
  }
});

// ü©∫ Rota de teste
app.get('/api/test', (req, res) => {
  console.log('\nü©∫ Health check realizado');
  res.json({ 
    message: 'Backend ENEM Pro+ funcionando!',
    timestamp: new Date().toISOString(),
    observacao: 'Language (ingl√™s/espanhol) apenas para disciplina Linguagens',
    novas_funcionalidades: [
      'Verifica√ß√£o de ader√™ncia ao tema',
      'Simula√ß√£o real dos crit√©rios ENEM',
      'Nota zero para fuga total do tema'
    ]
  });
});

app.listen(PORT, '0.0.0.0', () => {
  console.log('\nüöÄ SERVIDOR INICIADO');
  console.log(`   Porta: ${PORT}`);
  console.log(`   API ENEM: ${ENEM_API_BASE}`);
  console.log(`   üìö Matem√°tica/Humanas/Natureza: Portugu√™s (sem language)`);
  console.log(`   üåê Linguagens: Ingl√™s ou Espanhol (com language)`);
  console.log(`   üéØ NOVA: Verifica√ß√£o de ader√™ncia ao tema`);
  console.log(`   ‚ö†Ô∏è  Fuga do tema = Nota conforme ENEM real`);
  console.log(`   Logs: HABILITADOS`);
  console.log(`   Timestamp: ${new Date().toISOString()}`);
  console.log('‚ïê'.repeat(50));
});
